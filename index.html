<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <title>JapLearner - Japanese Learning Tool</title>
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkphcExlYXJuZXIiLAogICJzaG9ydF9uYW1lIjogIkphcExlYXJuZXIiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzFhMWEyZSIsCiAgInRoZW1lX2NvbG9yIjogIiMxYTFhMmUiCn0=">
    <style>
        :root {
            --primary: #1a1a2e;
            --secondary: #16213e;
            --accent: #0f3460;
            --highlight: #e94560;
            --text: #f1f1f1;
            --text-secondary: #b8b8b8;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #ef4444;
            --card-bg: rgba(255, 255, 255, 0.05);
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        [data-theme="light"] {
            --primary: #f8f9fa;
            --secondary: #e9ecef;
            --accent: #dee2e6;
            --highlight: #e94560;
            --text: #212529;
            --text-secondary: #495057;
            --card-bg: rgba(255, 255, 255, 0.8);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body {
            background-color: var(--primary);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease;
        }

        .app-container {
            max-width: 100%;
            min-height: 100vh;
            padding: 0;
            position: relative;
        }

        header {
            background-color: var(--secondary);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--highlight);
        }

        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn.active {
            background-color: var(--accent);
            color: var(--text);
        }

        .theme-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        main {
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .text-import-container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
            position: relative;
        }

        h2 {
            margin-bottom: 1rem;
            color: var(--highlight);
        }

        .text-input {
            width: 100%;
            min-height: 150px;
            background-color: var(--secondary);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 1rem;
            color: var(--text);
            font-size: 1rem;
            resize: vertical;
            margin-bottom: 1rem;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--highlight);
        }

        .char-count {
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .btn {
            background-color: var(--highlight);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-height: 56px;
        }

        .btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
.translation-result {
    background-color: var(--card-bg);
    border-radius: 12px;
    padding: 1.5rem;
    margin-top: 1rem;
    box-shadow: var(--shadow);
    display: none;
}

.mode-toggle {
    display: flex;
    justify-content: center;
    gap: 1rem;
    margin-bottom: 1rem;
}

.mode-toggle-btn {
    background-color: var(--accent);
    color: var(--text);
    border: none;
    padding: 0.8rem 1.5rem;
    border-radius: 30px;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.mode-toggle-btn.active {
    background-color: var(--highlight);
    color: white;
}
        .sentence-display {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            font-size: 1.8rem;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
            line-height: 1.6;
            user-select: text;
        }

        .word-selection-box {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
            display: none;
        }

        .selected-word {
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: var(--secondary);
            border-radius: 8px;
        }

        .word-selection-box input {
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: var(--secondary);
            border: 1px solid var(--accent);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
        }

        .sentence-controls {
            position: sticky;
            bottom: 0;
            background-color: var(--secondary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
        }

        .control-btn {
            background: var(--accent);
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text);
            font-size: 1.5rem;
            transition: all 0.2s ease;
        }

        .control-btn:active {
            transform: scale(0.95);
            background-color: var(--highlight);
        }

        .lang-selector {
            background-color: var(--secondary);
            color: var(--text);
            border: 1px solid var(--accent);
            border-radius: 20px;
            padding: 0.5rem 1rem;
            margin-left: 0.5rem;
            font-size: 0.9rem;
        }

        .translation-display {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            margin: 1rem 0;
            box-shadow: var(--shadow);
            font-size: 1.2rem;
            display: none;
        }

        .bucket-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .bucket-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .bucket-card:hover {
            transform: translateY(-5px);
        }

        .bucket-card.new { border-top: 4px solid #3b82f6; }
        .bucket-card.easy { border-top: 4px solid var(--success); }
        .bucket-card.medium { border-top: 4px solid var(--warning); }
        .bucket-card.hard { border-top: 4px solid var(--danger); }
        .bucket-card.retired { border-top: 4px solid var(--text-secondary); }

        .bucket-count {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .bucket-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Updated matching game styles */
        .matching-game-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 300px);
            margin-top: 1rem;
        }

        .matching-game-columns {
            display: flex;
            flex: 1;
            gap: 1rem;
            overflow: hidden;
        }

        .matching-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .matching-column-header {
            text-align: center;
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background-color: var(--secondary);
            border-radius: 8px;
        }

        .word-card {
            background-color: var(--accent);
            padding: 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
            margin-bottom: 0.75rem;
            font-size: 1.2rem;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            word-break: break-word;
        }

        .word-card:hover {
            transform: translateY(-2px);
            background-color: rgba(15, 52, 96, 0.8);
        }

        .word-card.selected {
            background-color: var(--highlight);
        }

        .word-card.correct {
            background-color: var(--success);
            opacity: 0.7;
        }

        .word-card.incorrect {
            background-color: var(--danger);
            opacity: 0.7;
        }

        .review-container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
        }

        .review-question {
            font-size: 1.8rem;
            margin-bottom: 1.5rem;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .hard-mode-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .hard-mode-btn {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hard-mode-btn.knew-it {
            background-color: var(--success);
            color: white;
        }

        .hard-mode-btn.didnt-know {
            background-color: var(--danger);
            color: white;
        }

        .hard-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .progress-container {
            margin: 1rem 0;
            text-align: center;
        }

        .progress-bar {
            background-color: var(--secondary);
            border-radius: 4px;
            height: 8px;
            margin-bottom: 0.5rem;
            overflow: hidden;
        }

        .progress-text {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .confirmation-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .confirmation-dialog.show {
            opacity: 1;
        }

        .toast {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--secondary);
            color: var(--text);
            padding: 1rem 2rem;
            border-radius: 30px;
            box-shadow: var(--shadow);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            background-color: rgba(74, 222, 128, 0.2);
            border: 1px solid var(--success);
        }

        .toast.error {
            background-color: rgba(239, 68, 68, 0.2);
            border: 1px solid var(--danger);
        }

        .sentence-counter {
            text-align: center;
            margin-bottom: 1rem;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .paste-indicator {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background-color: var(--highlight);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            animation: pulse 2s infinite;
            cursor: pointer;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .resources-container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 1rem;
            box-shadow: var(--shadow);
        }

        .resources-title {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: var(--highlight);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .resources-list {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }

        .resource-link {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.8rem;
            background-color: var(--secondary);
            border-radius: 8px;
            color: var(--text);
            text-decoration: none;
            transition: transform 0.2s ease;
        }

        .resource-link:hover {
            transform: translateX(5px);
            background-color: var(--accent);
        }

        .sound-toggle {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            width: 50px;
            height: 50px;
            background-color: var(--highlight);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            z-index: 100;
            box-shadow: var(--shadow);
            cursor: pointer;
        }

@media (max-width: 600px) {
    .sentence-display {
        font-size: 1.5rem;
        padding: 1.5rem;
    }
    
    .control-btn {
        width: 50px;
        height: 50px;
        font-size: 1.2rem;
    }
    
    .bucket-container {
        grid-template-columns: 1fr 1fr;
    }

    .matching-game-columns {
        flex-direction: row; /* Keep columns side by side */
        gap: 0.5rem; /* Reduce gap between columns */
    }

    .matching-column {
        max-height: 60vh; /* Adjust height */
        overflow-y: auto; /* Allow scrolling */
    }

    .word-card {
        padding: 1rem;
        min-height: 70px;
        font-size: 1.1rem;
    }

    .paste-indicator {
        top: auto;
        bottom: 1rem;
        right: 1rem;
    }
}
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="logo">JapLearner</div>
            <div class="nav-tabs">
                <button class="nav-btn active" data-view="text-import">Reader</button>
                <button class="nav-btn" data-view="vocab-review">Vocabulary</button>
            </div>
            <button class="theme-toggle" id="theme-toggle">🌙</button>
        </header>
        
        <main>
            <section id="text-import-view" class="view active">
                <div class="text-import-container">
                    <h2>Import Japanese Text</h2>
                    <p>Paste Japanese text below to start learning (max 5,000 characters)</p>
                    <div id="paste-indicator" class="paste-indicator" style="display: none;">
                        📋 Click to paste
                    </div>
                    <textarea class="text-input" id="text-input" placeholder="例: 猫が寝ている。犬が走っている。..."></textarea>
                    <div class="char-count"><span id="char-count">0</span>/5000 characters</div>
                    <button class="btn" id="process-text">
                        <span>Process Text</span>
                    </button>
                    <button class="btn" id="clear-text" style="background-color: var(--danger); margin-top: 1rem;">
                        Clear Text
                    </button>
<button class="btn" id="show-history-btn" style="background-color: var(--accent); margin-top: 1rem;">
    View History
</button>
<div class="mode-toggle">
    <button class="mode-toggle-btn active" data-mode="import">Import Japanese Text</button>
    <button class="mode-toggle-btn" data-mode="translate">Translate to Japanese</button>
</div>
<div class="text-import-container" id="text-import-container">
                </div>
<div class="text-import-container" id="translate-container" style="display: none;">
    <h2>Translate to Japanese</h2>
    <p>Type or speak text in your language to translate to Japanese</p>
    <textarea class="text-input" id="translate-input" placeholder="Example: The cat is sleeping. The dog is running..."></textarea>
    <div class="char-count"><span id="translate-char-count">0</span>/5000 characters</div>
    <button class="btn" id="translate-to-japanese">
        <span>Translate to Japanese</span>
    </button>
</div>
                <div class="resources-container">
                    <h3 class="resources-title">📚 Japanese Learning Resources</h3>
                    <div class="resources-list">
                        <a href="https://www3.nhk.or.jp/news/easy/" class="resource-link" target="_blank" rel="noopener">
                            <span>NHK Easy News</span>
                        </a>
                        <a href="https://news.yahoo.co.jp/" class="resource-link" target="_blank" rel="noopener">
                            <span>Yahoo Japan News</span>
                        </a>
                        <a href="https://www3.nhk.or.jp/news/" class="resource-link" target="_blank" rel="noopener">
                            <span>NHK News</span>
                        </a>
                        <a href="https://www.asahi.com/" class="resource-link" target="_blank" rel="noopener">
                            <span>Asahi Shimbun</span>
                        </a>
                    </div>
                </div>
            </section>
            
            <section id="reading-view" class="view">
                <div class="word-selection-box" id="word-selection-box">
                    <div class="selected-word" id="selected-word"></div>
                    <input type="text" class="translation-input" id="vocab-translation" placeholder="Enter translation...">
                    <button class="btn" id="add-to-vocab">Add to Vocabulary</button>
                </div>
                <div class="sentence-display" id="sentence-display">
                    Select text to begin reading
                </div>
                <div class="sentence-counter" id="sentence-counter">
                    Sentence 0/0
                </div>
                <div class="translation-display" id="translation-display"></div>
                
                <div class="sentence-controls">
                    <button class="control-btn" id="prev-sentence">←</button>
                    <button class="control-btn" id="translate-btn">翻訳</button>
                    <button class="control-btn" id="tts-button">🔊</button>
                    <button class="control-btn" id="next-sentence">→</button>
                </div>
                <select id="translation-lang" class="lang-selector">
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                </select>
            </section>
            
            <section id="vocab-review-view" class="view">
                <h2>Vocabulary Review</h2>
                <p>Select a difficulty level to start reviewing</p>
                
                <div class="bucket-container">
                    <div class="bucket-card new" data-bucket="new">
                        <div class="bucket-count" id="new-count">0</div>
                        <div class="bucket-label">New Words</div>
                    </div>
                    <div class="bucket-card easy" data-bucket="easy">
                        <div class="bucket-count" id="easy-count">0</div>
                        <div class="bucket-label">Easy</div>
                    </div>
                    <div class="bucket-card medium" data-bucket="medium">
                        <div class="bucket-count" id="medium-count">0</div>
                        <div class="bucket-label">Medium</div>
                    </div>
                    <div class="bucket-card hard" data-bucket="hard">
                        <div class="bucket-count" id="hard-count">0</div>
                        <div class="bucket-label">Hard</div>
                    </div>
                </div>
                
                <button class="btn" id="start-review" disabled>Select a difficulty to start</button>
                <button class="btn" id="wipe-data-btn" style="background-color: var(--danger); margin-top: 1rem;">
                    Wipe All Data
                </button>
<button class="btn" id="manage-vocab-btn" style="background-color: var(--accent); margin-top: 1rem;">
    Manage Vocabulary
</button>
            </section>
            
            <section id="review-mode-view" class="view">
                <div class="review-container">
                    <div class="progress-container">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill" style="width: 0%; height: 8px; background-color: var(--highlight); border-radius: 4px;"></div>
                        </div>
                        <div class="progress-text" id="progress-text">0/0</div>
                    </div>
                    
                    <div class="review-question" id="review-question"></div>
                    
                    <div id="matching-game-container" class="matching-game-container" style="display: none;">
                        <div class="matching-game-columns">
                            <div class="matching-column" id="left-column">
                                <div class="matching-column-header" id="left-header"></div>
                            </div>
                            <div class="matching-column" id="right-column">
                                <div class="matching-column-header" id="right-header"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="hard-mode-container" class="hard-mode-buttons" style="display: none;">
                        <button class="hard-mode-btn knew-it" id="knew-it-btn">I know this</button>
                        <button class="hard-mode-btn didnt-know" id="didnt-know-btn">Don't know</button>
                    </div>
                </div>
                
                <button class="btn" id="exit-review">Exit Review</button>
            </section>
<section id="manage-vocab-view" class="view">
    <h2>Manage Vocabulary</h2>
    <p>View and delete words from your vocabulary</p>
    
    <div class="resources-container" id="vocab-list-container">
        <div class="bucket-container">
            <div class="bucket-card new" data-bucket="new">
                <div class="bucket-count" id="manage-new-count">0</div>
                <div class="bucket-label">New Words</div>
            </div>
            <div class="bucket-card easy" data-bucket="easy">
                <div class="bucket-count" id="manage-easy-count">0</div>
                <div class="bucket-label">Easy</div>
            </div>
            <div class="bucket-card medium" data-bucket="medium">
                <div class="bucket-count" id="manage-medium-count">0</div>
                <div class="bucket-label">Medium</div>
            </div>
            <div class="bucket-card hard" data-bucket="hard">
                <div class="bucket-count" id="manage-hard-count">0</div>
                <div class="bucket-label">Hard</div>
            </div>
        </div>
        
        <div id="vocab-list" style="max-height: 300px; overflow-y: auto; margin-top: 1rem;">
            <!-- Words will appear here -->
        </div>
    </div>
    
    <button class="btn" id="back-to-review-btn" style="margin-top: 1rem;">
        Back to Vocabulary Review
    </button>
</section>
<section id="history-view" class="view">
    <h2>Recently Read Texts</h2>
    <p>Your recently imported texts (saved for 24 hours)</p>
    
    <div id="history-list" class="resources-container">
        <!-- History items will appear here -->
    </div>
    
    <button class="btn" id="clear-history-btn" style="background-color: var(--danger); margin-top: 1rem;">
        Clear All History
    </button>
    <button class="btn" id="back-to-import-btn" style="margin-top: 1rem;">
        Back to Text Import
    </button>
</section>
        </main>
        
        <div class="confirmation-dialog" id="wipe-confirmation" style="display: none;">
            <div class="dialog-content" style="background-color: var(--card-bg); padding: 1.5rem; border-radius: 12px; max-width: 400px; margin: 0 auto; text-align: center; box-shadow: var(--shadow);">
                <h3 style="margin-bottom: 1rem; color: var(--danger);">Warning!</h3>
                <p style="margin-bottom: 1.5rem;">This will delete ALL your saved sentences and vocabulary. This cannot be undone!</p>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button class="btn" id="confirm-wipe" style="background-color: var(--danger);">Yes, Delete Everything</button>
                    <button class="btn" id="cancel-wipe" style="background-color: var(--accent);">Cancel</button>
                </div>
            </div>
        </div>
        
        <div class="toast" id="toast"></div>
        <div class="sound-toggle" id="sound-toggle">🔊</div>
    </div>

    <script>
// App state
const state = {
    currentView: 'text-import',
    translatedText: '',
    sentences: [],
    currentSentenceIndex: 0,
    vocabWords: [],
    reviewMode: null,
    reviewWords: [],
    currentReviewIndex: 0,
    reviewStats: {
        correct: 0,
        incorrect: 0
    },
    theme: localStorage.getItem('theme') || 'dark',
    soundsEnabled: localStorage.getItem('soundsEnabled') !== 'false',
    audioContext: null,
    sounds: {},
    currentHardWord: null,
    currentHardStreak: 0,
    textHistory: []
};

// Initialize audio context and sounds
function initAudio() {
    try {
        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Correct answer sound (Japanese "correct" bell)
        state.sounds.correct = () => {
            const osc = state.audioContext.createOscillator();
            const gain = state.audioContext.createGain();
            osc.type = 'triangle';
            osc.frequency.value = 880;
            gain.gain.value = 0.5;
            
            osc.connect(gain);
            gain.connect(state.audioContext.destination);
            
            osc.start();
            osc.frequency.exponentialRampToValueAtTime(1760, state.audioContext.currentTime + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, state.audioContext.currentTime + 0.3);
            osc.stop(state.audioContext.currentTime + 0.3);
        };
        
        // Incorrect answer sound (Japanese "wrong" buzzer)
        state.sounds.incorrect = () => {
            const osc = state.audioContext.createOscillator();
            const gain = state.audioContext.createGain();
            osc.type = 'sawtooth';
            osc.frequency.value = 220;
            gain.gain.value = 0.5;
            
            osc.connect(gain);
            gain.connect(state.audioContext.destination);
            
            osc.start();
            osc.frequency.exponentialRampToValueAtTime(110, state.audioContext.currentTime + 0.3);
            gain.gain.exponentialRampToValueAtTime(0.001, state.audioContext.currentTime + 0.5);
            osc.stop(state.audioContext.currentTime + 0.5);
        };
        
        // Round complete sound (Japanese "congratulations" flourish)
        state.sounds.complete = () => {
            const notes = [523.25, 587.33, 659.25, 698.46, 783.99, 880];
            const gain = state.audioContext.createGain();
            gain.gain.value = 0.5;
            gain.connect(state.audioContext.destination);
            
            notes.forEach((freq, i) => {
                const osc = state.audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = freq;
                osc.connect(gain);
                
                osc.start(state.audioContext.currentTime + i * 0.1);
                osc.stop(state.audioContext.currentTime + i * 0.1 + 0.3);
            });
        };
        
        // Card flip sound
        state.sounds.flip = () => {
            const osc = state.audioContext.createOscillator();
            const gain = state.audioContext.createGain();
            osc.type = 'square';
            osc.frequency.value = 440;
            gain.gain.value = 0.3;
            
            osc.connect(gain);
            gain.connect(state.audioContext.destination);
            
            osc.start();
            osc.frequency.exponentialRampToValueAtTime(880, state.audioContext.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, state.audioContext.currentTime + 0.1);
            osc.stop(state.audioContext.currentTime + 0.1);
        };
    } catch (e) {
        console.warn('Audio initialization failed:', e);
        state.soundsEnabled = false;
    }
}

// Play sound if enabled
function playSound(name) {
    if (state.soundsEnabled && state.sounds[name]) {
        try {
            state.sounds[name]();
        } catch (e) {
            console.warn('Sound playback failed:', e);
        }
    }
}

// Toggle sound on/off
function toggleSounds() {
    state.soundsEnabled = !state.soundsEnabled;
    localStorage.setItem('soundsEnabled', state.soundsEnabled);
    document.getElementById('sound-toggle').textContent = state.soundsEnabled ? '🔊' : '🔇';
    showToast(`Sounds ${state.soundsEnabled ? 'enabled' : 'disabled'}`);
}

// Toast notification
function showToast(message, type = '') {
    const toast = document.getElementById('toast');
    toast.textContent = message;
    toast.className = 'toast';
    toast.classList.add(type);
    toast.classList.add('show');
    
    setTimeout(() => {
        toast.classList.remove('show');
    }, 3000);
}

// DOM Elements
const elements = {
    views: {
        textImport: document.getElementById('text-import-view'),
        reading: document.getElementById('reading-view'),
        vocabReview: document.getElementById('vocab-review-view'),
        reviewMode: document.getElementById('review-mode-view')
    },
    textInput: document.getElementById('text-input'),
    charCount: document.getElementById('char-count'),
    processTextBtn: document.getElementById('process-text'),
    clearTextBtn: document.getElementById('clear-text'),
    sentenceDisplay: document.getElementById('sentence-display'),
    prevSentenceBtn: document.getElementById('prev-sentence'),
    nextSentenceBtn: document.getElementById('next-sentence'),
    ttsButton: document.getElementById('tts-button'),
    wordSelectionBox: document.getElementById('word-selection-box'),
    selectedWord: document.getElementById('selected-word'),
    vocabTranslation: document.getElementById('vocab-translation'),
    addToVocabBtn: document.getElementById('add-to-vocab'),
    translationDisplay: document.getElementById('translation-display'),
    translateBtn: document.getElementById('translate-btn'),
    translationLang: document.getElementById('translation-lang'),
    bucketCounts: {
        new: document.getElementById('new-count'),
        easy: document.getElementById('easy-count'),
        medium: document.getElementById('medium-count'),
        hard: document.getElementById('hard-count')
    },
    startReviewBtn: document.getElementById('start-review'),
    reviewQuestion: document.getElementById('review-question'),
    exitReviewBtn: document.getElementById('exit-review'),
    progressFill: document.getElementById('progress-fill'),
    progressText: document.getElementById('progress-text'),
    toast: document.getElementById('toast'),
    themeToggle: document.getElementById('theme-toggle'),
    soundToggle: document.getElementById('sound-toggle'),
    pasteIndicator: document.getElementById('paste-indicator'),
    matchingGameContainer: document.getElementById('matching-game-container'),
    leftColumn: document.getElementById('left-column'),
    rightColumn: document.getElementById('right-column'),
    leftHeader: document.getElementById('left-header'),
    rightHeader: document.getElementById('right-header'),
    hardModeContainer: document.getElementById('hard-mode-container'),
    knewItBtn: document.getElementById('knew-it-btn'),
    didntKnowBtn: document.getElementById('didnt-know-btn'),
    voiceInputBtn: document.createElement('button')
};

// Set up voice input button
elements.voiceInputBtn.innerHTML = '🎤';
elements.voiceInputBtn.style.background = 'none';
elements.voiceInputBtn.style.border = 'none';
elements.voiceInputBtn.style.fontSize = '1.5rem';
elements.voiceInputBtn.style.cursor = 'pointer';
elements.voiceInputBtn.style.marginLeft = '0.5rem';

// Insert the button next to the translate input
const translateInput = document.getElementById('translate-input');
translateInput.parentNode.insertBefore(elements.voiceInputBtn, translateInput.nextSibling);

// Database operations

// Initialize IndexedDB
const DB_NAME = 'JapaneseLearnerDB';
const DB_VERSION = 1;
const STORE_SENTENCES = 'sentences';
const STORE_VOCAB = 'vocabulary';

let db;

async function openDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            
            if (!db.objectStoreNames.contains(STORE_SENTENCES)) {
                const sentencesStore = db.createObjectStore(STORE_SENTENCES, { keyPath: 'id' });
                sentencesStore.createIndex('position', 'position', { unique: true });
            }
            
            if (!db.objectStoreNames.contains(STORE_VOCAB)) {
                const vocabStore = db.createObjectStore(STORE_VOCAB, { keyPath: 'id' });
                vocabStore.createIndex('bucket', 'bucket', { unique: false });
                vocabStore.createIndex('word', 'word', { unique: true });
            } else {
                const vocabStore = event.target.transaction.objectStore(STORE_VOCAB);
                if (!vocabStore.indexNames.contains('word')) {
                    vocabStore.createIndex('word', 'word', { unique: true });
                }
            }
        };
        
        request.onsuccess = (event) => {
            resolve(event.target.result);
        };
        
        request.onerror = (event) => {
            reject(event.target.error);
        };
    });
}

function wipeAllData() {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_SENTENCES, STORE_VOCAB], 'readwrite');
        const sentencesStore = transaction.objectStore(STORE_SENTENCES);
        const vocabStore = transaction.objectStore(STORE_VOCAB);
        
        sentencesStore.clear();
        vocabStore.clear();
        
        transaction.oncomplete = () => resolve();
        transaction.onerror = (event) => reject(event.target.error);
    });
}

function showWipeConfirmation() {
    const dialog = document.getElementById('wipe-confirmation');
    dialog.style.display = 'flex';
    setTimeout(() => dialog.classList.add('show'), 10);
}

function hideWipeConfirmation() {
    const dialog = document.getElementById('wipe-confirmation');
    dialog.classList.remove('show');
    setTimeout(() => dialog.style.display = 'none', 300);
}

function showHistoryView() {
    // Load history from localStorage
    const savedHistory = localStorage.getItem('textHistory');
    if (savedHistory) {
        state.textHistory = JSON.parse(savedHistory);
    }
    
    // Filter out expired items (older than 24 hours)
    const now = new Date();
    state.textHistory = state.textHistory.filter(item => {
        const itemDate = new Date(item.timestamp);
        return (now - itemDate) < (24 * 60 * 60 * 1000); // 24 hours
    });
    
    // Display history
    const historyList = document.getElementById('history-list');
    historyList.innerHTML = '';
    
    if (state.textHistory.length === 0) {
        historyList.innerHTML = '<p>No recent texts found</p>';
    } else {
        state.textHistory.forEach((item, index) => {
            const historyItem = document.createElement('div');
            historyItem.className = 'resource-link';
            historyItem.style.marginBottom = '0.5rem';
            
            const preview = item.text.length > 100 ? 
                item.text.substring(0, 100) + '...' : 
                item.text;
            
            historyItem.innerHTML = `
                <span>${preview}</span>
                <button class="nav-btn" style="margin-left: auto; padding: 0.2rem 0.5rem;" 
                    data-history-index="${index}">Load</button>
                <button class="nav-btn" style="background-color: var(--danger); padding: 0.2rem 0.5rem;" 
                    data-history-index="${index}">Delete</button>
            `;
            
            historyList.appendChild(historyItem);
        });
        
        // Add event listeners to the new buttons
        document.querySelectorAll('[data-history-index]').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const index = parseInt(e.target.dataset.historyIndex);
                if (e.target.textContent === 'Load') {
                    loadHistoryItem(index);
                } else {
                    deleteHistoryItem(index);
                }
            });
        });
    }
    
    showView('history-view');
}

function loadHistoryItem(index) {
    const item = state.textHistory[index];
    elements.textInput.value = item.text;
    elements.charCount.textContent = text.length;
    showView('text-import-view');
    showToast('Text loaded from history');
}

function deleteHistoryItem(index) {
    state.textHistory.splice(index, 1);
    localStorage.setItem('textHistory', JSON.stringify(state.textHistory));
    showHistoryView();
    showToast('History item deleted');
}

function clearHistory() {
    state.textHistory = [];
    localStorage.removeItem('textHistory');
    showHistoryView();
    showToast('History cleared');
}

// Database operations
function addSentences(sentences) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_SENTENCES], 'readwrite');
        const store = transaction.objectStore(STORE_SENTENCES);
        
        store.clear().onsuccess = () => {
            sentences.forEach((sentence, index) => {
                sentence.position = index;
                store.add(sentence);
            });
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) => reject(event.target.error);
        };
    });
}

function getAllSentences() {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_SENTENCES], 'readonly');
        const store = transaction.objectStore(STORE_SENTENCES);
        const index = store.index('position');
        const request = index.getAll();
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = (event) => reject(event.target.error);
    });
}

function updateSentence(sentence) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_SENTENCES], 'readwrite');
        const store = transaction.objectStore(STORE_SENTENCES);
        const request = store.put(sentence);
        
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}

function addVocabWord(word) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_VOCAB], 'readwrite');
        const store = transaction.objectStore(STORE_VOCAB);
        
        if (!store.indexNames.contains('word')) {
            const addRequest = store.add(word);
            addRequest.onsuccess = () => resolve();
            addRequest.onerror = (event) => reject(event.target.error);
            return;
        }
        
        const wordIndex = store.index('word');
        const request = wordIndex.get(word.word);
        
        request.onsuccess = () => {
            if (request.result) {
                reject(new Error('Word already exists in vocabulary'));
            } else {
                const addRequest = store.add(word);
                addRequest.onsuccess = () => resolve();
                addRequest.onerror = (event) => reject(event.target.error);
            }
        };
        
        request.onerror = (event) => reject(event.target.error);
    });
}

function getVocabByBucket(bucket) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_VOCAB], 'readonly');
        const store = transaction.objectStore(STORE_VOCAB);
        const index = store.index('bucket');
        const request = index.getAll(IDBKeyRange.only(bucket));
        
        request.onsuccess = () => resolve(request.result);
        request.onerror = (event) => reject(event.target.error);
    });
}

function updateVocabWord(word) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_VOCAB], 'readwrite');
        const store = transaction.objectStore(STORE_VOCAB);
        const request = store.put(word);
        
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}

function countVocabByBucket() {
    return new Promise((resolve, reject) => {
        const buckets = ['new', 'easy', 'medium', 'hard'];
        const counts = {};
        
        const transaction = db.transaction([STORE_VOCAB], 'readonly');
        const store = transaction.objectStore(STORE_VOCAB);
        const index = store.index('bucket');
        
        let completed = 0;
        
        buckets.forEach(bucket => {
            const request = index.count(IDBKeyRange.only(bucket));
            
            request.onsuccess = () => {
                counts[bucket] = request.result;
                completed++;
                
                if (completed === buckets.length) {
                    resolve(counts);
                }
            };
            
            request.onerror = (event) => reject(event.target.error);
        });
    });
}

// Text processing
function splitSentences(text) {
    const roughSentences = text.split(/(?<=[。！？\n])/);
    const sentences = [];
    
    roughSentences.forEach(roughSentence => {
        const trimmed = roughSentence.trim();
        if (trimmed.length === 0) return;
        
        if (trimmed.includes('。') || trimmed.includes('！') || trimmed.includes('？')) {
            const subSentences = trimmed.split(/(?<=[。！？])/);
            subSentences.forEach(sub => {
                const subTrimmed = sub.trim();
                if (subTrimmed.length > 0) sentences.push(subTrimmed);
            });
        } else {
            sentences.push(trimmed);
        }
    });
    
    return sentences;
}

async function translateToJapanese(text, sourceLang) {
    try {
        const response = await fetch(
            `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${sourceLang}|ja`
        );

        if (!response.ok) throw new Error('Translation failed');

        const data = await response.json();
        if (data.responseData && data.responseData.translatedText) {
            return data.responseData.translatedText;
        } else {
            throw new Error('No translation found');
        }
    } catch (error) {
        console.error('Translation error:', error);
        return "Translation failed. Please try again.";
    }
}

function toggleTranslationMode(showTranslate) {
    if (showTranslate) {
        document.getElementById('text-import-container').style.display = 'none';
        document.getElementById('translate-container').style.display = 'block';
        document.querySelector('.mode-toggle-btn[data-mode="import"]').classList.remove('active');
        document.querySelector('.mode-toggle-btn[data-mode="translate"]').classList.add('active');
    } else {
        document.getElementById('text-import-container').style.display = 'block';
        document.getElementById('translate-container').style.display = 'none';
        document.querySelector('.mode-toggle-btn[data-mode="import"]').classList.add('active');
        document.querySelector('.mode-toggle-btn[data-mode="translate"]').classList.remove('active');
    }
}

async function translateSentence(sentence) {
    try {
        const currentSentence = state.sentences[state.currentSentenceIndex];
        if (currentSentence.user_translation) {
            return currentSentence.user_translation;
        }

        const targetLang = elements.translationLang.value;
        const response = await fetch(
            `https://api.mymemory.translated.net/get?q=${encodeURIComponent(sentence)}&langpair=ja|${targetLang}`
        );

        if (!response.ok) throw new Error('Translation failed');

        const data = await response.json();
        if (data.responseData && data.responseData.translatedText) {
            return data.responseData.translatedText;
        } else {
            throw new Error('No translation found');
        }
    } catch (error) {
        console.error('Translation error:', error);
        return "Translation unavailable";
    }
}

// TTS functionality
function speakText(text, rate = 1.0) {
    if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'ja-JP';
        utterance.rate = rate;
        
        const voices = speechSynthesis.getVoices();
        const japaneseVoice = voices.find(voice => 
            voice.lang === 'ja-JP' || voice.lang.startsWith('ja')
        );
        
        if (japaneseVoice) {
            utterance.voice = japaneseVoice;
        }
        
        speechSynthesis.cancel();
        speechSynthesis.speak(utterance);
    }
}

// View management
function showView(viewId) {
    Object.values(elements.views).forEach(view => {
        view.classList.remove('active');
    });
    
    const view = document.getElementById(viewId);
    if (view) {
        view.classList.add('active');
        state.currentView = viewId;
    }
}

function updateBucketCounts() {
    countVocabByBucket().then(counts => {
        Object.entries(counts).forEach(([bucket, count]) => {
            if (elements.bucketCounts[bucket]) {
                elements.bucketCounts[bucket].textContent = count;
            }
        });
        
        const selectedBucket = state.reviewMode;
        if (selectedBucket && counts[selectedBucket] > 0) {
            elements.startReviewBtn.disabled = false;
            elements.startReviewBtn.textContent = `Review ${selectedBucket} words`;
        } else {
            elements.startReviewBtn.disabled = true;
            elements.startReviewBtn.textContent = 'Select a difficulty to start';
        }
    });
}

function displaySentence() {
    if (state.sentences.length === 0) {
        elements.sentenceDisplay.textContent = 'No sentences available.';
        if (elements.translationDisplay) {
            elements.translationDisplay.style.display = 'none';
        }
        document.getElementById('sentence-counter').textContent = 'Sentence 0/0';
        return;
    }
    
    const sentence = state.sentences[state.currentSentenceIndex];
    elements.sentenceDisplay.textContent = sentence.original;
    elements.wordSelectionBox.style.display = 'none';
    
    document.getElementById('sentence-counter').textContent = 
        `Sentence ${state.currentSentenceIndex + 1}/${state.sentences.length}`;
    
    if (elements.translationDisplay) {
        elements.translationDisplay.style.display = 'none';
        
        if (sentence.cached_translation) {
            elements.translationDisplay.textContent = sentence.cached_translation;
            elements.translationDisplay.style.display = 'block';
        }
    }
}

// Vocabulary review functions
async function startReview(bucket) {
    state.reviewMode = bucket;
    state.reviewWords = await getVocabByBucket(bucket);
    
    if (state.reviewWords.length === 0) {
        showToast('No words to review in this category!', 'error');
        return;
    }
    
    state.reviewWords = shuffleArray(state.reviewWords);
    state.currentReviewIndex = 0;
    state.reviewStats = { correct: 0, incorrect: 0 };
    
    showView('review-mode-view');
    
    if (bucket === 'hard') {
        setupHardMode();
    } else {
        setupMatchingGame();
    }
}

function setupMatchingGame() {
    elements.matchingGameContainer.style.display = 'block';
    elements.hardModeContainer.style.display = 'none';
    
    // Clear previous cards
    elements.leftColumn.innerHTML = '<div class="matching-column-header" id="left-header"></div>';
    elements.rightColumn.innerHTML = '<div class="matching-column-header" id="right-header"></div>';
    
    // Get words for this round (max 5)
    const wordsToShow = state.reviewWords.slice(state.currentReviewIndex, state.currentReviewIndex + 5);
    state.currentRoundWords = wordsToShow;
    
    // Set column headers based on mode
    if (state.reviewMode === 'new' || state.reviewMode === 'easy') {
        elements.leftHeader.textContent = "English";
        elements.rightHeader.textContent = "Japanese";
        
        // English cards on left (translations)
        const englishCards = shuffleArray([...wordsToShow]).map(word => ({
            ...word,
            type: 'english',
            text: word.translation
        }));
        
        // Japanese cards on right (words)
        const japaneseCards = shuffleArray([...wordsToShow]).map(word => ({
            ...word,
            type: 'japanese',
            text: word.word
        }));
        
        // Add cards to columns
        englishCards.forEach(word => {
            const card = createWordCard(word);
            elements.leftColumn.appendChild(card);
        });
        
        japaneseCards.forEach(word => {
            const card = createWordCard(word);
            elements.rightColumn.appendChild(card);
        });
        
    } else { // medium mode
        elements.leftHeader.textContent = "Japanese";
        elements.rightHeader.textContent = "English";
        
        // Japanese cards on left (words)
        const japaneseCards = shuffleArray([...wordsToShow]).map(word => ({
            ...word,
            type: 'japanese',
            text: word.word
        }));
        
        // English cards on right (translations)
        const englishCards = shuffleArray([...wordsToShow]).map(word => ({
            ...word,
            type: 'english',
            text: word.translation
        }));
        
        // Add cards to columns
        japaneseCards.forEach(word => {
            const card = createWordCard(word);
            elements.leftColumn.appendChild(card);
        });
        
        englishCards.forEach(word => {
            const card = createWordCard(word);
            elements.rightColumn.appendChild(card);
        });
    }
    
    // Update progress
    elements.progressText.textContent = `Words: ${state.currentReviewIndex + 1}-${Math.min(state.currentReviewIndex + 5, state.reviewWords.length)}/${state.reviewWords.length}`;
    elements.progressFill.style.width = `${(state.currentReviewIndex / state.reviewWords.length) * 100}%`;
}

function createWordCard(word) {
    const card = document.createElement('div');
    card.className = 'word-card';
    card.dataset.id = word.id;
    card.dataset.type = word.type;
    card.textContent = word.text;
    
    card.addEventListener('click', function() {
        playSound('flip');
        
        // Play TTS for Japanese words in medium mode or english words in easy/new mode
        if ((word.type === 'japanese' && (state.reviewMode === 'medium')) ||
            (word.type === 'english' && (state.reviewMode === 'new' || state.reviewMode === 'easy'))) {
            const matchingWord = state.currentRoundWords.find(w => w.id === word.id);
            if (matchingWord) {
                speakText(matchingWord.word);
            }
        }
        
        selectCard(this, word.type);
    });
    
    return card;
}

function setupHardMode() {
    elements.matchingGameContainer.style.display = 'none';
    elements.hardModeContainer.style.display = 'flex';
    
    if (state.currentReviewIndex >= state.reviewWords.length) {
        // Review complete
        elements.reviewQuestion.textContent = "Review complete!";
        elements.hardModeContainer.style.display = 'none';
        return;
    }
    
    state.currentHardWord = state.reviewWords[state.currentReviewIndex];
    elements.reviewQuestion.textContent = state.currentHardWord.word;
    
    // Update progress
    elements.progressText.textContent = `Word ${state.currentReviewIndex + 1}/${state.reviewWords.length}`;
    elements.progressFill.style.width = `${((state.currentReviewIndex + 1) / state.reviewWords.length) * 100}%`;
}

// Track selected cards
let selectedLeftCard = null;
let selectedRightCard = null;

function selectCard(cardElement, cardType) {
    if (cardElement.classList.contains('correct')) {
        return;
    }

    if (cardElement.classList.contains('incorrect')) {
        cardElement.classList.remove('incorrect');
    }

    // Determine if card is in left or right column
    const isLeftColumn = cardElement.parentElement === elements.leftColumn;
    
    if (isLeftColumn) {
        if (selectedLeftCard) {
            selectedLeftCard.classList.remove('selected');
        }
        selectedLeftCard = cardElement;
    } else {
        if (selectedRightCard) {
            selectedRightCard.classList.remove('selected');
        }
        selectedRightCard = cardElement;
    }

    cardElement.classList.add('selected');

    if (selectedLeftCard && selectedRightCard) {
        checkMatch(selectedLeftCard, selectedRightCard);
    }
}

function checkMatch(leftCard, rightCard) {
    const leftId = leftCard.dataset.id;
    const rightId = rightCard.dataset.id;
    
    if (leftId === rightId) {
        leftCard.classList.remove('selected');
        leftCard.classList.add('correct');
        rightCard.classList.remove('selected');
        rightCard.classList.add('correct');
        
        state.reviewStats.correct++;
        playSound('correct');
        showToast('Correct!', 'success');
        
        selectedLeftCard = null;
        selectedRightCard = null;
        
        // Check if all cards are matched
        const allCards = document.querySelectorAll('.word-card');
        const matchedCards = document.querySelectorAll('.word-card.correct');
        
        if (matchedCards.length === allCards.length) {
            playSound('complete');
            showToast('Round completed!', 'success');
            
            // Update words in the database
            state.currentRoundWords.forEach(word => {
                word.streak = (word.streak || 0) + 1;
                
                if (word.streak >= 3) {
                    if (word.bucket === 'new') {
                        word.bucket = 'easy';
                        word.streak = 0;
                    } 
                    else if (word.bucket === 'easy') {
                        word.bucket = 'medium';
                        word.streak = 0;
                    }
                    else if (word.bucket === 'medium') {
                        word.bucket = 'hard';
                        word.streak = 0;
                    }
                    
                    updateVocabWord(word);
                }
            });
            
            // Move to next set of words
            state.currentReviewIndex += 5;
            if (state.currentReviewIndex < state.reviewWords.length) {
                setTimeout(() => {
                    setupMatchingGame();
                }, 1500);
            } else {
                // Review complete
                setTimeout(() => {
                    showView('vocab-review-view');
                    updateBucketCounts();
                }, 1500);
            }
        }
    } else {
        leftCard.classList.remove('selected');
        leftCard.classList.add('incorrect');
        rightCard.classList.remove('selected');
        rightCard.classList.add('incorrect');
        
        state.reviewStats.incorrect++;
        playSound('incorrect');
        showToast('Try again!', 'error');
        
        setTimeout(() => {
            leftCard.classList.remove('incorrect');
            rightCard.classList.remove('incorrect');
            selectedLeftCard = null;
            selectedRightCard = null;
        }, 1000);
    }
}

function handleHardModeResponse(knewIt) {
    if (!state.currentHardWord) return;
    
    if (knewIt) {
        state.currentHardStreak++;
        
        if (state.currentHardStreak >= 3) {
            // Remove word from vocabulary (retired)
            const transaction = db.transaction([STORE_VOCAB], 'readwrite');
            const store = transaction.objectStore(STORE_VOCAB);
            store.delete(state.currentHardWord.id);
            
            showToast('Word retired!', 'success');
        } else {
            // Move to next bucket
            if (state.currentHardWord.bucket === 'hard') {
                state.currentHardWord.bucket = 'medium';
            } else if (state.currentHardWord.bucket === 'medium') {
                state.currentHardWord.bucket = 'easy';
            } else if (state.currentHardWord.bucket === 'easy') {
                state.currentHardWord.bucket = 'new';
            }
            
            updateVocabWord(state.currentHardWord);
            showToast('Word moved to easier bucket', 'success');
        }
    } else {
        state.currentHardStreak = 0;
        state.currentHardWord.bucket = 'new';
        updateVocabWord(state.currentHardWord);
        showToast('Word moved back to new words', 'error');
    }
    
    // Move to next word
    state.currentReviewIndex++;
    if (state.currentReviewIndex < state.reviewWords.length) {
        setupHardMode();
    } else {
        // Review complete
        showView('vocab-review-view');
        updateBucketCounts();
    }
}

function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

function toggleTheme() {
    state.theme = state.theme === 'dark' ? 'light' : 'dark';
    localStorage.setItem('theme', state.theme);
    document.documentElement.setAttribute('data-theme', state.theme);
    elements.themeToggle.textContent = state.theme === 'dark' ? '🌙' : '☀️';
}

// Check clipboard for text to paste
async function checkClipboard() {
    try {
        const text = await navigator.clipboard.readText();
        if (text && text.trim().length > 0) {
            elements.pasteIndicator.style.display = 'flex';
        }
    } catch (err) {
        console.log('Clipboard access denied:', err);
    }
}

function setupEventListeners() {
    document.querySelectorAll('.mode-toggle-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            toggleTranslationMode(btn.dataset.mode === 'translate');
        });
    });

    elements.voiceInputBtn.addEventListener('click', () => {
        if (!('webkitSpeechRecognition' in window)) {
            showToast('Voice input not supported in your browser', 'error');
            return;
        }

        const recognition = new webkitSpeechRecognition();
        recognition.lang = 'en-US';
        recognition.interimResults = false;

        recognition.onstart = () => {
            elements.voiceInputBtn.innerHTML = '🔴';
            showToast('Listening...');
        };

        recognition.onresult = (event) => {
            const transcript = event.results[0][0].transcript;
            document.getElementById('translate-input').value = transcript;
            document.getElementById('translate-char-count').textContent = transcript.length;
        };

        recognition.onerror = (event) => {
            showToast('Voice input error: ' + event.error, 'error');
            elements.voiceInputBtn.innerHTML = '🎤';
        };

        recognition.onend = () => {
            elements.voiceInputBtn.innerHTML = '🎤';
        };

        recognition.start();
    });

    // History buttons
    document.getElementById('show-history-btn').addEventListener('click', showHistoryView);
    document.getElementById('back-to-import-btn').addEventListener('click', () => showView('text-import-view'));
    document.getElementById('clear-history-btn').addEventListener('click', clearHistory);
    
    // Wipe data button
    document.getElementById('wipe-data-btn').addEventListener('click', showWipeConfirmation);

    // Confirmation dialog buttons
    document.getElementById('confirm-wipe').addEventListener('click', async () => {
        hideWipeConfirmation();
        try {
            await wipeAllData();
            state.sentences = [];
            state.vocabWords = [];
            await updateBucketCounts();
            showToast('All data has been deleted', 'success');
            document.querySelector('.nav-btn[data-view="text-import"]').classList.add('active');
            document.querySelector('.nav-btn[data-view="vocab-review"]').classList.remove('active');
            showView('text-import-view');
        } catch (error) {
            console.error('Error wiping data:', error);
            showToast('Failed to delete data', 'error');
        }
    });

    document.getElementById('cancel-wipe').addEventListener('click', hideWipeConfirmation);

    // Clear text button
    elements.clearTextBtn.addEventListener('click', () => {
        elements.textInput.value = '';
        elements.charCount.textContent = '0';
        showToast('Text cleared', 'success');
    });

    // Navigation
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            showView(btn.dataset.view + '-view');
        });
    });

    // Text import
    elements.textInput.addEventListener('input', () => {
        const text = elements.textInput.value;
        elements.charCount.textContent = text.length;
    });

    // Translate input
    document.getElementById('translate-input').addEventListener('input', () => {
        const text = document.getElementById('translate-input').value;
        document.getElementById('translate-char-count').textContent = text.length;
    });

    // Paste indicator
    elements.pasteIndicator.addEventListener('click', async () => {
        try {
            const text = await navigator.clipboard.readText();
            if (text) {
                elements.textInput.value = text;
                elements.charCount.textContent = text.length;
                elements.pasteIndicator.style.display = 'none';
            }
        } catch (err) {
            console.log('Failed to paste:', err);
        }
    });

    // Process text button event listener
    elements.processTextBtn.addEventListener('click', async () => {
        const text = elements.textInput.value.trim();
        if (text.length === 0) {
            showToast('Please enter some text', 'error');
            return;
        }
        
        // Save to history
        state.textHistory.unshift({
            text: text,
            timestamp: new Date().toISOString()
        });
        
        // Keep only the last 10 items
        if (state.textHistory.length > 10) {
            state.textHistory = state.textHistory.slice(0, 10);
        }
        
        localStorage.setItem('textHistory', JSON.stringify(state.textHistory));
                    
        if (text.length > 5000) {
            showToast('Text exceeds 5000 characters', 'error');
            return;
        }
        
        const sentences = splitSentences(text);
        
        if (sentences.length === 0) {
            showToast('No sentences found in text', 'error');
            return;
        }
        
        const sentenceObjects = sentences.map((sentence, index) => ({
            id: generateUUID(),
            original: sentence,
            user_translation: '',
            position: index
        }));
        
        try {
            await addSentences(sentenceObjects);
            state.sentences = await getAllSentences();
            state.currentSentenceIndex = 0;
            
            showView('reading-view');
            displaySentence();
            showToast(`Processed ${sentences.length} sentences!`, 'success');
        } catch (error) {
            console.error('Error saving sentences:', error);
            showToast('Error processing text', 'error');
        }
    });

    // Translate to Japanese button event listener
    document.getElementById('translate-to-japanese').addEventListener('click', async () => {
        const text = document.getElementById('translate-input').value.trim();
        if (text.length === 0) {
            showToast('Please enter some text to translate', 'error');
            return;
        }

        if (text.length > 5000) {
            showToast('Text exceeds 5000 characters', 'error');
            return;
        }

        try {
            const targetLang = 'en'; // Assuming English source
            const response = await fetch(
                `https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${targetLang}|ja`
            );

            if (!response.ok) throw new Error('Translation failed');

            const data = await response.json();
            if (data.responseData && data.responseData.translatedText) {
                state.translatedText = data.responseData.translatedText;
                document.getElementById('text-input').value = state.translatedText;
                document.getElementById('char-count').textContent = state.translatedText.length;
                showToast('Translation complete!', 'success');
            } else {
                throw new Error('No translation found');
            }
        } catch (error) {
            console.error('Translation error:', error);
            showToast('Translation failed. Please try again.', 'error');
        }
    });

    // Reading view controls
    elements.prevSentenceBtn.addEventListener('click', () => {
        if (state.currentSentenceIndex > 0) {
            state.currentSentenceIndex--;
            displaySentence();
        }
    });

    elements.translateBtn.addEventListener('click', async () => {
        if (state.sentences.length === 0 || !elements.translationDisplay) return;
        
        const sentence = state.sentences[state.currentSentenceIndex].original;
        elements.translationDisplay.style.display = 'block';
        elements.translationDisplay.textContent = "Translating...";
        
        const translation = await translateSentence(sentence);
        elements.translationDisplay.textContent = translation;
        
        state.sentences[state.currentSentenceIndex].cached_translation = translation;
        
        if (state.currentSentenceIndex < state.sentences.length - 1) {
            const nextSentences = state.sentences.slice(
                state.currentSentenceIndex + 1,
                Math.min(state.currentSentenceIndex + 4, state.sentences.length)
            );
            
            nextSentences.forEach(async (sentenceObj, index) => {
                if (!sentenceObj.user_translation) {
                    const translation = await translateSentence(sentenceObj.original);
                    state.sentences[state.currentSentenceIndex + 1 + index].cached_translation = translation;
                }
            });
        }
    });

    elements.nextSentenceBtn.addEventListener('click', () => {
        if (state.currentSentenceIndex < state.sentences.length - 1) {
            state.currentSentenceIndex++;
            displaySentence();
        }
    });
    
    elements.ttsButton.addEventListener('click', () => {
        if (state.sentences.length > 0) {
            const sentence = state.sentences[state.currentSentenceIndex].original;
            speakText(sentence);
        }
    });

    // Word selection
    elements.sentenceDisplay.addEventListener('mouseup', handleTextSelection);
    elements.sentenceDisplay.addEventListener('touchend', handleTextSelection);

    function handleTextSelection() {
        const selection = window.getSelection().toString().trim();
        if (selection.length > 0) {
            elements.selectedWord.textContent = selection;
            elements.vocabTranslation.value = '';
            elements.wordSelectionBox.style.display = 'block';
            
            if (window.innerWidth <= 600) {
                elements.wordSelectionBox.scrollIntoView({ behavior: 'smooth' });
            }
        }
    }

    // Add to vocab handler
    elements.addToVocabBtn.addEventListener('click', async () => {
        const word = elements.selectedWord.textContent;
        const translation = elements.vocabTranslation.value.trim();
        
        if (!translation) {
            showToast('Please enter a translation', 'error');
            return;
        }
        
        const newWord = {
            id: generateUUID(),
            word: word,
            translation: translation,
            sentence_id: state.sentences[state.currentSentenceIndex].id,
            bucket: 'new',
            streak: 0,
            consecutiveMisses: 0
        };
        
        try {
            await addVocabWord(newWord);
            showToast(`"${word}" added to vocabulary!`, 'success');
            elements.wordSelectionBox.style.display = 'none';
            updateBucketCounts();
        } catch (error) {
            if (error.message === 'Word already exists in vocabulary') {
                showToast(`"${word}" is already in your vocabulary!`, 'error');
            } else {
                showToast('Error adding word', 'error');
                console.error(error);
            }
        }
    });

    // Vocabulary review
    document.querySelectorAll('.bucket-card').forEach(card => {
        card.addEventListener('click', () => {
            document.querySelectorAll('.bucket-card').forEach(c => {
                c.style.opacity = '1';
                c.style.transform = 'scale(1)';
            });
            
            card.style.opacity = '0.9';
            card.style.transform = 'scale(0.98)';
            state.reviewMode = card.dataset.bucket;
            
            elements.startReviewBtn.disabled = false;
            elements.startReviewBtn.textContent = `Review ${card.dataset.bucket} words`;
        });
    });
    
    elements.startReviewBtn.addEventListener('click', () => {
        if (state.reviewMode) {
            startReview(state.reviewMode);
        }
    });

    // Review mode
    elements.exitReviewBtn.addEventListener('click', () => {
        showView('vocab-review-view');
    });

    // Hard mode buttons
    elements.knewItBtn.addEventListener('click', () => {
        handleHardModeResponse(true);
    });

    elements.didntKnowBtn.addEventListener('click', () => {
        handleHardModeResponse(false);
    });

    // Theme toggle
    elements.themeToggle.addEventListener('click', toggleTheme);

    // Sound toggle
    elements.soundToggle.addEventListener('click', toggleSounds);
}

// Initialize the app
async function initApp() {
    try {
        db = await openDatabase();
        
        state.sentences = await getAllSentences();
        
        if (state.sentences.length > 0) {
            document.querySelector('.nav-btn[data-view="text-import"]').classList.remove('active');
            document.querySelector('.nav-btn[data-view="vocab-review"]').classList.add('active');
            showView('vocab-review-view');
        }
        
        await updateBucketCounts();
        setupEventListeners();
        
        // Apply theme
        document.documentElement.setAttribute('data-theme', state.theme);
        elements.themeToggle.textContent = state.theme === 'dark' ? '🌙' : '☀️';
        
        // Initialize audio
        initAudio();
        elements.soundToggle.textContent = state.soundsEnabled ? '🔊' : '🔇';
        
        // Check clipboard for paste
        checkClipboard();
        
        // Pre-warm TTS
        if ('speechSynthesis' in window) {
            speechSynthesis.getVoices();
        }
        
        // Service worker registration for PWA
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('sw.js');
                console.log('ServiceWorker registration successful with scope:', registration.scope);
            } catch (error) {
                console.log('Service Worker registration failed:', error);
            }
        }
        
    } catch (error) {
        console.error('Initialization error:', error);
        showToast('Failed to initialize app', 'error');
        
        // Try to recover by deleting and recreating the database
        try {
            await new Promise((resolve, reject) => {
                const req = indexedDB.deleteDatabase(DB_NAME);
                req.onsuccess = resolve;
                req.onerror = reject;
                req.onblocked = () => reject(new Error('Database is blocked'));
            });
            
            window.location.reload();
        } catch (recoveryError) {
            console.error('Recovery failed:', recoveryError);
        }
    }
}

// Start the app
window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
