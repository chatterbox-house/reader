<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#1a1a2e">
    <title>JapLearner - Japanese Learning Tool</title>
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIkphcExlYXJuZXIiLAogICJzaG9ydF9uYW1lIjogIkphcExlYXJuZXIiLAogICJzdGFydF91cmwiOiAiLiIsCiAgImRpc3BsYXkiOiAic3RhbmRhbG9uZSIsCiAgImJhY2tncm91bmRfY29sb3IiOiAiIzFhMWEyZSIsCiAgInRoZW1lX2NvbG9yIjogIiMxYTFhMmUiCn0=">
    <style>
        :root {
            --primary: #1a1a2e;
            --secondary: #16213e;
            --accent: #0f3460;
            --highlight: #e94560;
            --text: #f1f1f1;
            --text-secondary: #b8b8b8;
            --success: #4ade80;
            --warning: #fbbf24;
            --danger: #ef4444;
            --card-bg: rgba(255, 255, 255, 0.05);
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        [data-theme="light"] {
            --primary: #f8f9fa;
            --secondary: #e9ecef;
            --accent: #dee2e6;
            --highlight: #e94560;
            --text: #212529;
            --text-secondary: #495057;
            --card-bg: rgba(255, 255, 255, 0.8);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        body {
            background-color: var(--primary);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease;
        }

        .app-container {
            max-width: 100%;
            min-height: 100vh;
            padding: 0;
            position: relative;
        }

        header {
            background-color: var(--secondary);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: var(--shadow);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--highlight);
        }

        .nav-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .nav-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn.active {
            background-color: var(--accent);
            color: var(--text);
        }

        .theme-toggle {
            background: none;
            border: none;
            color: var(--text);
            cursor: pointer;
            font-size: 1.2rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        .theme-toggle:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        main {
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
        }

        .view {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .view.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .text-import-container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
        }

        h2 {
            margin-bottom: 1rem;
            color: var(--highlight);
        }

        .text-input {
            width: 100%;
            min-height: 150px;
            background-color: var(--secondary);
            border: 1px solid var(--accent);
            border-radius: 8px;
            padding: 1rem;
            color: var(--text);
            font-size: 1rem;
            resize: vertical;
            margin-bottom: 1rem;
        }

        .text-input:focus {
            outline: none;
            border-color: var(--highlight);
        }

        .char-count {
            text-align: right;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }

        .btn {
            background-color: var(--highlight);
            color: white;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 30px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            min-height: 56px;
        }

        .btn:disabled {
            background-color: var(--text-secondary);
            cursor: not-allowed;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .sentence-display {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            font-size: 1.8rem;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
            line-height: 1.6;
        }
<div class="word-selection-box" id="word-selection-box" style="display: none;">
    <div class="selected-word" id="selected-word"></div>
    <input type="text" class="translation-input" id="vocab-translation" placeholder="Enter translation...">
    <button class="btn" id="add-to-vocab">Add to Vocabulary</button>
</div>
        .sentence-controls {
            position: sticky;
            bottom: 0;
            background-color: var(--secondary);
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.2);
        }

        .control-btn {
            background: var(--accent);
            border: none;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text);
            font-size: 1.5rem;
            transition: all 0.2s ease;
        }

        .control-btn:active {
            transform: scale(0.95);
            background-color: var(--highlight);
        }
.lang-selector {
    background-color: var(--secondary);
    color: var(--text);
    border: 1px solid var(--accent);
    border-radius: 20px;
    padding: 0.5rem 1rem;
    margin-left: 0.5rem;
    font-size: 0.9rem;
}

.translation-display {
    background-color: var(--card-bg);
    border-radius: 12px;
    padding: 1rem;
    margin: 1rem 0;
    box-shadow: var(--shadow);
    font-size: 1.2rem;
    display: none;
}
.word-selection-box {
    background-color: var(--card-bg);
    border-radius: 12px;
    padding: 1rem;
    margin-bottom: 1rem;
    box-shadow: var(--shadow);
}

.selected-word {
    font-size: 1.5rem;
    text-align: center;
    margin-bottom: 1rem;
    padding: 0.5rem;
    background-color: var(--secondary);
    border-radius: 8px;
}

.word-selection-box input {
    width: 100%;
    padding: 1rem;
    margin-bottom: 1rem;
    background-color: var(--secondary);
    border: 1px solid var(--accent);
    border-radius: 8px;
    color: var(--text);
    font-size: 1rem;
}

        .bucket-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .bucket-card {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 1rem;
            text-align: center;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .bucket-card:hover {
            transform: translateY(-5px);
        }

        .bucket-card.new { border-top: 4px solid #3b82f6; }
        .bucket-card.easy { border-top: 4px solid var(--success); }
        .bucket-card.medium { border-top: 4px solid var(--warning); }
        .bucket-card.hard { border-top: 4px solid var(--danger); }
        .bucket-card.retired { border-top: 4px solid var(--text-secondary); }

        .bucket-count {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        .bucket-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
.matching-game {
    display: flex;
    gap: 1rem;
    margin-top: 2rem;
}

.japanese-words, .english-words {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}
.japanese-words::before {
    content: attr(data-label);
    display: block;
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
}

.english-words::before {
    content: attr(data-label);
    display: block;
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
}
.word-card {
    background-color: var(--accent);
    padding: 1rem;
    border-radius: 8px;
    cursor: pointer;
    text-align: center;
    transition: all 0.2s ease;
}

.word-card:hover {
    transform: translateY(-2px);
    background-color: rgba(15, 52, 96, 0.8);
}

.word-card.selected {
    background-color: var(--highlight);
}

.word-card.correct {
    background-color: var(--success);
    opacity: 0.7;
}

.word-card.incorrect {
    background-color: var(--danger);
    opacity: 0.7;
}
        .review-container {
            background-color: var(--card-bg);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
            margin-bottom: 1rem;
            box-shadow: var(--shadow);
        }

        .review-question {
            font-size: 2rem;
            margin-bottom: 2rem;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .review-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .option-btn {
            background-color: var(--accent);
            border: none;
            border-radius: 12px;
            padding: 1.2rem;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .option-btn:hover {
            transform: translateY(-2px);
            background-color: rgba(15, 52, 96, 0.8);
        }

        .review-typing {
            margin-bottom: 2rem;
        }

        .typing-input {
            width: 100%;
            padding: 1rem;
            font-size: 1.5rem;
            text-align: center;
            background-color: var(--secondary);
            border: 2px solid var(--accent);
            border-radius: 12px;
            color: var(--text);
            margin-bottom: 1rem;
        }

        .typing-input:focus {
            outline: none;
            border-color: var(--highlight);
        }

        .toast {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background-color: var(--secondary);
            color: var(--text);
            padding: 1rem 2rem;
            border-radius: 30px;
            box-shadow: var(--shadow);
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .toast.success {
            background-color: rgba(74, 222, 128, 0.2);
            border: 1px solid var(--success);
        }

        .toast.error {
            background-color: rgba(239, 68, 68, 0.2);
            border: 1px solid var(--danger);
        }

        @media (max-width: 600px) {
            .sentence-display {
                font-size: 1.5rem;
                padding: 1.5rem;
            }
            
            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
            
            .review-options {
                grid-template-columns: 1fr;
            }
            
            .bucket-container {
                grid-template-columns: 1fr 1fr;
            }
}
.sentence-counter {
    text-align: center;
    margin-bottom: 1rem;
    color: var(--text-secondary);
    font-size: 0.9rem;
}
.progress-container {
    margin: 1rem 0;
    text-align: center;
}

.progress-bar {
    background-color: var(--secondary);
    border-radius: 4px;
    height: 8px;
    margin-bottom: 0.5rem;
    overflow: hidden;
}

.progress-text {
    font-size: 0.9rem;
    color: var(--text-secondary);
}
      
    </style>
</head>
<body>
    <div class="app-container">
        <header>
            <div class="logo">JapLearner</div>
            <div class="nav-tabs">
                <button class="nav-btn active" data-view="text-import">Reader</button>
                <button class="nav-btn" data-view="vocab-review">Vocabulary</button>
            </div>
            <button class="theme-toggle" id="theme-toggle">🌙</button>
        </header>
        
        <main>
            <section id="text-import-view" class="view active">
                <div class="text-import-container">
                    <h2>Import Japanese Text</h2>
                    <p>Paste Japanese text below to start learning (max 5,000 characters)</p>
                    <textarea class="text-input" id="text-input" placeholder="例: 猫が寝ている。犬が走っている。..."></textarea>
                    <div class="char-count"><span id="char-count">0</span>/5000 characters</div>
                    <button class="btn" id="process-text">
                        <span>Process Text</span>
                    </button>
                </div>
            </section>
            
            <section id="reading-view" class="view">
<div class="word-selection-box" id="word-selection-box" style="display: none;">
    <div class="selected-word" id="selected-word"></div>
    <input type="text" class="translation-input" id="vocab-translation" placeholder="Enter translation...">
    <button class="btn" id="add-to-vocab">Add to Vocabulary</button>
</div>
                <div class="sentence-display" id="sentence-display">
                    Select text to begin reading
                </div>
<div class="sentence-counter" id="sentence-counter">
    Sentence 0/0
</div>
                <div class="translation-display" id="translation-display"></div>
                
               <div class="sentence-controls">
    <button class="control-btn" id="prev-sentence">←</button>
    <button class="control-btn" id="translate-btn">翻訳</button>
    <button class="control-btn" id="tts-button">🔊</button>
    <button class="control-btn" id="next-sentence">→</button>
</div>
<select id="translation-lang" class="lang-selector">
    <option value="en">English</option>
    <option value="es">Spanish</option>
    <option value="fr">French</option>
    <option value="de">German</option>
</select>
            </section>
            
            <section id="vocab-review-view" class="view">
                <h2>Vocabulary Review</h2>
                <p>Select a difficulty level to start reviewing</p>
                
                <div class="bucket-container">
                    <div class="bucket-card new" data-bucket="new">
                        <div class="bucket-count" id="new-count">0</div>
                        <div class="bucket-label">New Words</div>
                    </div>
                    <div class="bucket-card easy" data-bucket="easy">
                        <div class="bucket-count" id="easy-count">0</div>
                        <div class="bucket-label">Easy</div>
                    </div>
                    <div class="bucket-card medium" data-bucket="medium">
                        <div class="bucket-count" id="medium-count">0</div>
                        <div class="bucket-label">Medium</div>
                    </div>
                    <div class="bucket-card hard" data-bucket="hard">
                        <div class="bucket-count" id="hard-count">0</div>
                        <div class="bucket-label">Hard</div>
                    </div>
                </div>
                
                <button class="btn" id="start-review" disabled>Select a difficulty to start</button>
            </section>
            
<section id="review-mode-view" class="view">
    <div class="review-container">
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%; height: 8px; background-color: var(--highlight); border-radius: 4px;"></div>
            </div>
            <div class="progress-text" id="progress-text">0/0</div>
        </div>
        
        <div class="review-question" id="review-question"></div>
        
        <div class="matching-game">
            <div class="japanese-words" id="japanese-words"></div>
            <div class="english-words" id="english-words"></div>
        </div>
    </div>
    
    <button class="btn" id="exit-review">Exit Review</button>
</section>
        </main>
        
        <div class="toast" id="toast"></div>
    </div>

    <script>
        // App state
        const state = {
            currentView: 'text-import',
            sentences: [],
            currentSentenceIndex: 0,
            vocabWords: [],
            reviewMode: null,
            reviewWords: [],
            currentReviewIndex: 0,
            reviewStats: {
                correct: 0,
                incorrect: 0
            },
            theme: localStorage.getItem('theme') || 'dark'
        };
        // Toast notification
function showToast(message, type = '') {
    elements.toast.textContent = message;
    elements.toast.className = 'toast';
    elements.toast.classList.add(type);
    elements.toast.classList.add('show');
    
    setTimeout(() => {
        elements.toast.classList.remove('show');
    }, 3000);
}
// DOM Elements
const elements = {
    views: {
        textImport: document.getElementById('text-import-view'),
        reading: document.getElementById('reading-view'),
        vocabReview: document.getElementById('vocab-review-view'),
        reviewMode: document.getElementById('review-mode-view')
    },
    textInput: document.getElementById('text-input'),
    charCount: document.getElementById('char-count'),
    processTextBtn: document.getElementById('process-text'),
    sentenceDisplay: document.getElementById('sentence-display'),
    prevSentenceBtn: document.getElementById('prev-sentence'),
    nextSentenceBtn: document.getElementById('next-sentence'),
    ttsButton: document.getElementById('tts-button'),
    wordSelectionBox: document.getElementById('word-selection-box'),
    selectedWord: document.getElementById('selected-word'),
    vocabTranslation: document.getElementById('vocab-translation'),
    addToVocabBtn: document.getElementById('add-to-vocab'),
    translationDisplay: document.getElementById('translation-display'),
    translateBtn: document.getElementById('translate-btn'),
    translationLang: document.getElementById('translation-lang'), // <-- This comma was missing
    bucketCounts: {
        new: document.getElementById('new-count'),
        easy: document.getElementById('easy-count'),
        medium: document.getElementById('medium-count'),
        hard: document.getElementById('hard-count')
    },
            startReviewBtn: document.getElementById('start-review'),
            reviewQuestion: document.getElementById('review-question'),
            reviewOptions: document.getElementById('review-options'),
            reviewTyping: document.getElementById('review-typing'),

            exitReviewBtn: document.getElementById('exit-review'),
            progressFill: document.getElementById('progress-fill'),
            progressText: document.getElementById('progress-text'),
            toast: document.getElementById('toast'),
            themeToggle: document.getElementById('theme-toggle')
        };
        
        // Initialize IndexedDB
        const DB_NAME = 'JapaneseLearnerDB';
        const DB_VERSION = 1;
        const STORE_SENTENCES = 'sentences';
        const STORE_VOCAB = 'vocabulary';
        
        let db;
        
function openDatabase() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            
            if (!db.objectStoreNames.contains(STORE_SENTENCES)) {
                const sentencesStore = db.createObjectStore(STORE_SENTENCES, { keyPath: 'id' });
                sentencesStore.createIndex('position', 'position', { unique: true });
            }
            
            if (!db.objectStoreNames.contains(STORE_VOCAB)) {
                const vocabStore = db.createObjectStore(STORE_VOCAB, { keyPath: 'id' });
                vocabStore.createIndex('bucket', 'bucket', { unique: false });
                vocabStore.createIndex('word', 'word', { unique: true });
            } else {
                // If store exists but index doesn't, create it
                const vocabStore = event.target.transaction.objectStore(STORE_VOCAB);
                if (!vocabStore.indexNames.contains('word')) {
                    vocabStore.createIndex('word', 'word', { unique: true });
                }
            }
        };
        
        request.onsuccess = (event) => {
            db = event.target.result;
            resolve(db);
        };
        
        request.onerror = (event) => {
            reject('Database error: ' + event.target.errorCode);
        };
    });
}
        
        // Database operations
function addSentences(sentences) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_SENTENCES], 'readwrite');
        const store = transaction.objectStore(STORE_SENTENCES);
        
        // First clear existing sentences
        store.clear().onsuccess = () => {
            // Then add new sentences with unique positions
            sentences.forEach((sentence, index) => {
                sentence.position = index; // Ensure unique position
                store.add(sentence);
            });
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) => reject(event.target.error);
        };
    });
}
        
        function getAllSentences() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_SENTENCES], 'readonly');
                const store = transaction.objectStore(STORE_SENTENCES);
                // Use the position index to get in order
                const index = store.index('position');
                const request = index.getAll();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
        function updateSentence(sentence) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_SENTENCES], 'readwrite');
                const store = transaction.objectStore(STORE_SENTENCES);
                const request = store.put(sentence);
                
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
function addVocabWord(word) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_VOCAB], 'readwrite');
        const store = transaction.objectStore(STORE_VOCAB);
        
        // First check if word exists using the word index
        const wordIndex = store.index('word');
        const request = wordIndex.get(word.word);
        
        request.onsuccess = () => {
            if (request.result) {
                // Word already exists
                reject(new Error('Word already exists in vocabulary'));
            } else {
                // Word doesn't exist, add it
                const addRequest = store.add(word);
                addRequest.onsuccess = () => resolve();
                addRequest.onerror = (event) => reject(event.target.error);
            }
        };
        
        request.onerror = (event) => reject(event.target.error);
    });
}
        
        function getVocabByBucket(bucket) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_VOCAB], 'readonly');
                const store = transaction.objectStore(STORE_VOCAB);
                const index = store.index('bucket');
                const request = index.getAll(IDBKeyRange.only(bucket));
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }
        
function updateVocabWord(word) {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_VOCAB], 'readwrite');
        const store = transaction.objectStore(STORE_VOCAB);
        const request = store.put(word);
        
        request.onsuccess = () => resolve();
        request.onerror = (event) => reject(event.target.error);
    });
}
        
        function countVocabByBucket() {
            return new Promise((resolve, reject) => {
                const buckets = ['new', 'easy', 'medium', 'hard'];
                const counts = {};
                
                const transaction = db.transaction([STORE_VOCAB], 'readonly');
                const store = transaction.objectStore(STORE_VOCAB);
                const index = store.index('bucket');
                
                let completed = 0;
                
                buckets.forEach(bucket => {
                    const request = index.count(IDBKeyRange.only(bucket));
                    
                    request.onsuccess = () => {
                        counts[bucket] = request.result;
                        completed++;
                        
                        if (completed === buckets.length) {
                            resolve(counts);
                        }
                    };
                    
                    request.onerror = (event) => reject(event.target.error);
                });
            });
        }
        
        // Text processing - FIXED: Improved sentence splitting
        function splitSentences(text) {
            // Split by common Japanese sentence endings
            const roughSentences = text.split(/(?<=[。！？\n])/);
            const sentences = [];
            
            roughSentences.forEach(roughSentence => {
                const trimmed = roughSentence.trim();
                if (trimmed.length === 0) return;
                
                // Further split if multiple sentence endings in one segment
                if (trimmed.includes('。') || trimmed.includes('！') || trimmed.includes('？')) {
                    const subSentences = trimmed.split(/(?<=[。！？])/);
                    subSentences.forEach(sub => {
                        const subTrimmed = sub.trim();
                        if (subTrimmed.length > 0) sentences.push(subTrimmed);
                    });
                } else {
                    sentences.push(trimmed);
                }
            });
            
            return sentences;
        }
        async function translateSentence(sentence) {
    try {
        // First check if we have a user translation saved
        const currentSentence = state.sentences[state.currentSentenceIndex];
        if (currentSentence.user_translation) {
            return currentSentence.user_translation;
        }

        // Use MyMemory API
        const targetLang = elements.translationLang.value;
        const response = await fetch(
            `https://api.mymemory.translated.net/get?q=${encodeURIComponent(sentence)}&langpair=ja|${targetLang}`
        );

        if (!response.ok) throw new Error('Translation failed');

        const data = await response.json();
        if (data.responseData && data.responseData.translatedText) {
            return data.responseData.translatedText;
        } else {
            throw new Error('No translation found');
        }
    } catch (error) {
        console.error('Translation error:', error);
        return "Translation unavailable";
    }
}
        // TTS functionality
        function speakText(text, rate = 1.0) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'ja-JP';
                utterance.rate = rate;
                
                // Prefer Japanese voice if available
                const voices = speechSynthesis.getVoices();
                const japaneseVoice = voices.find(voice => 
                    voice.lang === 'ja-JP' || voice.lang.startsWith('ja')
                );
                
                if (japaneseVoice) {
                    utterance.voice = japaneseVoice;
                }
                
                speechSynthesis.cancel();
                speechSynthesis.speak(utterance);
            }
        }
        
        // View management
        function showView(viewId) {
            // Hide all views
            Object.values(elements.views).forEach(view => {
                view.classList.remove('active');
            });
            
            // Show requested view
            const view = document.getElementById(viewId);
            if (view) {
                view.classList.add('active');
                state.currentView = viewId;
            }
        }
        
        function updateBucketCounts() {
            countVocabByBucket().then(counts => {
                Object.entries(counts).forEach(([bucket, count]) => {
                    if (elements.bucketCounts[bucket]) {
                        elements.bucketCounts[bucket].textContent = count;
                    }
                });
                
                // Enable/disable review button based on word counts
                const selectedBucket = state.reviewMode;
                if (selectedBucket && counts[selectedBucket] > 0) {
                    elements.startReviewBtn.disabled = false;
                    elements.startReviewBtn.textContent = `Review ${selectedBucket} words`;
                } else {
                    elements.startReviewBtn.disabled = true;
                    elements.startReviewBtn.textContent = 'Select a difficulty to start';
                }
            });
        }
        
function displaySentence() {
    if (state.sentences.length === 0) {
        elements.sentenceDisplay.textContent = 'No sentences available.';
        if (elements.translationDisplay) {
            elements.translationDisplay.style.display = 'none';
        }
        // Update counter to show 0/0
        document.getElementById('sentence-counter').textContent = 'Sentence 0/0';
        return;
    }
    
    const sentence = state.sentences[state.currentSentenceIndex];
    elements.sentenceDisplay.textContent = sentence.original;
    elements.wordSelectionBox.style.display = 'none';
    
    // Update the sentence counter
    document.getElementById('sentence-counter').textContent = 
        `Sentence ${state.currentSentenceIndex + 1}/${state.sentences.length}`;
    
    // Rest of your existing code...
    if (elements.translationDisplay) {
        elements.translationDisplay.style.display = 'none';
        
        if (sentence.cached_translation) {
            elements.translationDisplay.textContent = sentence.cached_translation;
            elements.translationDisplay.style.display = 'block';
        }
    }
}
        
        // Vocabulary review functions
async function startReview(bucket) {
    state.reviewMode = bucket;
    state.reviewWords = await getVocabByBucket(bucket);
    
    if (state.reviewWords.length === 0) {
        showToast('No words to review in this category!', 'error');
        return;
    }
    
    // Shuffle words
    state.reviewWords = shuffleArray(state.reviewWords);
    state.currentReviewIndex = 0;
    state.reviewStats = { correct: 0, incorrect: 0 };
    
    showView('review-mode-view');
  setupMatchingGame();
}

    function setupMatchingGame() {
        // Clear previous cards
        document.getElementById('japanese-words').innerHTML = '';
        document.getElementById('english-words').innerHTML = '';

        // Only shuffle once at start
        if (!state.currentRoundWords) {
            state.currentRoundWords = shuffleArray([...state.reviewWords]).slice(0, 5);
        }
        
        const wordsToShow = state.currentRoundWords;

        // Set column labels based on mode
        if (state.reviewMode === 'new' || state.reviewMode === 'easy') {
            document.getElementById('japanese-words').dataset.label = "English";
            document.getElementById('english-words').dataset.label = "Japanese";
        } else {
            document.getElementById('japanese-words').dataset.label = "Japanese";
            document.getElementById('english-words').dataset.label = "English";
        }

        // Create cards in fixed order (don't reshuffle)
        const leftColumn = state.reviewMode === 'new' || state.reviewMode === 'easy' 
            ? wordsToShow.map(word => ({ ...word, type: 'english', text: word.translation }))
            : wordsToShow.map(word => ({ ...word, type: 'japanese', text: word.word }));

        const rightColumn = state.reviewMode === 'new' || state.reviewMode === 'easy'
            ? shuffleArray([...wordsToShow]).map(word => ({ ...word, type: 'japanese', text: word.word }))
            : shuffleArray([...wordsToShow]).map(word => ({ ...word, type: 'english', text: word.translation }));

        // Create left column cards
        leftColumn.forEach(word => {
            const card = document.createElement('div');
            card.className = 'word-card';
            card.dataset.id = word.id;
            card.textContent = word.text;
            card.addEventListener('click', function() {
                // Play TTS for Japanese words in medium/hard mode, or for English words in new/easy mode
                if ((word.type === 'japanese' && (state.reviewMode === 'medium' || state.reviewMode === 'hard')) ||
                    (word.type === 'english' && (state.reviewMode === 'new' || state.reviewMode === 'easy'))) {
                    // Find the matching Japanese word to play its TTS
                    const matchingWord = wordsToShow.find(w => w.id === word.id);
                    if (matchingWord) {
                        speakText(matchingWord.word);
                    }
                }
                selectCard(this, word.type);
            });
            document.getElementById('japanese-words').appendChild(card);
        });

        // Create right column cards
        rightColumn.forEach(word => {
            const card = document.createElement('div');
            card.className = 'word-card';
            card.dataset.id = word.id;
            card.textContent = word.text;
            card.addEventListener('click', function() {
                // Play TTS for Japanese words in medium/hard mode, or for English words in new/easy mode
                if ((word.type === 'japanese' && (state.reviewMode === 'medium' || state.reviewMode === 'hard')) ||
                    (word.type === 'english' && (state.reviewMode === 'new' || state.reviewMode === 'easy'))) {
                    // Find the matching Japanese word to play its TTS
                    const matchingWord = wordsToShow.find(w => w.id === word.id);
                    if (matchingWord) {
                        speakText(matchingWord.word);
                    }
                }
                selectCard(this, word.type);
            });
            document.getElementById('english-words').appendChild(card);
        });

        // Update progress
        const matchedCount = document.querySelectorAll('.word-card.correct').length / 2;
        elements.progressText.textContent = `Matched: ${matchedCount}/${wordsToShow.length}`;
    }

// Track selected cards
let selectedJapaneseCard = null;
let selectedEnglishCard = null;

function selectCard(cardElement, cardType) {
    // If card is already matched, ignore clicks
    if (cardElement.classList.contains('correct')) {
        return;
    }

    // Reset incorrect state if present
    if (cardElement.classList.contains('incorrect')) {
        cardElement.classList.remove('incorrect');
    }

    // Select the card based on its type
    if (cardType === 'japanese') {
        // Deselect previous selection if exists
        if (selectedJapaneseCard) {
            selectedJapaneseCard.classList.remove('selected');
        }
        selectedJapaneseCard = cardElement;
    } else {
        // Deselect previous selection if exists
        if (selectedEnglishCard) {
            selectedEnglishCard.classList.remove('selected');
        }
        selectedEnglishCard = cardElement;
    }

    // Highlight the selected card
    cardElement.classList.add('selected');

    // If both a Japanese and English card are selected, check for a match
    if (selectedJapaneseCard && selectedEnglishCard) {
        checkMatch(selectedJapaneseCard, selectedEnglishCard);
    }
}
function checkMatch(japaneseCard, englishCard) {
    const japaneseId = japaneseCard.dataset.id;
    const englishId = englishCard.dataset.id;
    
    if (japaneseId === englishId) {
        // Correct match
        japaneseCard.classList.remove('selected');
        japaneseCard.classList.add('correct');
        englishCard.classList.remove('selected');
        englishCard.classList.add('correct');
        
        state.reviewStats.correct++;
        showToast('Correct!', 'success');
        
        // Clear selections
        selectedJapaneseCard = null;
        selectedEnglishCard = null;
        
        // Check if all words are matched
        const allCards = document.querySelectorAll('.word-card');
        const matchedCards = document.querySelectorAll('.word-card.correct');
        
        if (matchedCards.length === allCards.length) {
            // All words matched!
            state.currentRoundWords = null;
            showToast('Round completed!', 'success');
            setTimeout(() => {
                state.currentReviewIndex++;
                setupMatchingGame();
            }, 2000);
        } else {
            // Update progress
            const matchedCount = matchedCards.length / 2;
            elements.progressText.textContent = `Matched: ${matchedCount}/${state.currentRoundWords.length}`;
        }
        
        // Find the word and update its bucket
        const matchedWord = state.reviewWords.find(w => w.id === japaneseId);
        if (matchedWord) {
            matchedWord.streak = (matchedWord.streak || 0) + 1;
            
            if (matchedWord.streak >= 3) {
                if (matchedWord.bucket === 'new') {
                    matchedWord.bucket = 'easy';
                    matchedWord.streak = 0;
                } 
                else if (matchedWord.bucket === 'easy') {
                    matchedWord.bucket = 'medium';
                    matchedWord.streak = 0;
                }
                else if (matchedWord.bucket === 'medium') {
                    matchedWord.bucket = 'hard';
                    matchedWord.streak = 0;
                }
                else if (matchedWord.bucket === 'hard') {
                    const transaction = db.transaction([STORE_VOCAB], 'readwrite');
                    const store = transaction.objectStore(STORE_VOCAB);
                    store.delete(matchedWord.id);
                    return;
                }
            
                updateVocabWord(matchedWord);
            }
        }
    } else {
        // Incorrect match
        japaneseCard.classList.remove('selected');
        japaneseCard.classList.add('incorrect');
        englishCard.classList.remove('selected');
        englishCard.classList.add('incorrect');
        
        state.reviewStats.incorrect++;
        showToast('Try again!', 'error');
        
        setTimeout(() => {
            japaneseCard.classList.remove('incorrect');
            englishCard.classList.remove('incorrect');
            selectedJapaneseCard = null;
            selectedEnglishCard = null;
        }, 1000);
    }
}    
function checkAnswer(isCorrect, word) {
    if (isCorrect) {
        showToast('Correct!', 'success');
        state.reviewStats.correct++;
        
        // Update word streak and bucket
        word.streak++;
        word.consecutiveMisses = 0; // Reset misses on correct answer
        
        // Progress to next bucket if streak is sufficient
        if (word.streak >= 3) {
            if (word.bucket === 'new') word.bucket = 'easy';
            else if (word.bucket === 'easy') word.bucket = 'medium';
            else if (word.bucket === 'medium') word.bucket = 'hard';
            word.streak = 0; // Reset streak after moving
        }
    } else {
        showToast('Incorrect. Try again!', 'error');
        state.reviewStats.incorrect++;
        
        // Reset streak and potentially demote
        word.streak = 0;
        word.consecutiveMisses = (word.consecutiveMisses || 0) + 1;
        
        // Demote after 2 consecutive misses
        if (word.consecutiveMisses >= 2) {
            if (word.bucket === 'hard') word.bucket = 'medium';
            else if (word.bucket === 'medium') word.bucket = 'easy';
            else if (word.bucket === 'easy') word.bucket = 'new';
            word.consecutiveMisses = 0;
        }
    }
    
    // Update word in database
    updateVocabWord(word).then(() => {
        state.currentReviewIndex++;
        setTimeout(setupMatchingGame, 1000);
    });
}
        

        
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }
        
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        function toggleTheme() {
            state.theme = state.theme === 'dark' ? 'light' : 'dark';
            localStorage.setItem('theme', state.theme);
            document.documentElement.setAttribute('data-theme', state.theme);
            elements.themeToggle.textContent = state.theme === 'dark' ? '🌙' : '☀️';
        }
        
        // Event listeners
        function setupEventListeners() {
            // Navigation
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showView(btn.dataset.view + '-view');
                });
            });
            
            // Text import
            elements.textInput.addEventListener('input', () => {
                const text = elements.textInput.value;
                elements.charCount.textContent = text.length;
            });
            
            elements.processTextBtn.addEventListener('click', async () => {
                const text = elements.textInput.value.trim();
                if (text.length === 0) {
                    showToast('Please enter some text', 'error');
                    return;
                }
                
                if (text.length > 5000) {
                    showToast('Text exceeds 5000 characters', 'error');
                    return;
                }
                
                // Split text into sentences
                const sentences = splitSentences(text);
                
                if (sentences.length === 0) {
                    showToast('No sentences found in text', 'error');
                    return;
                }
                
                // Create sentence objects
                const sentenceObjects = sentences.map((sentence, index) => ({
                    id: generateUUID(),
                    original: sentence,
                    user_translation: '',
                    position: index
                }));
                
    try {
        await addSentences(sentenceObjects);
        state.sentences = await getAllSentences();
        state.currentSentenceIndex = 0;
        
        // Update UI
        showView('reading-view');
        displaySentence(); // This will now show the counter
        showToast(`Processed ${sentences.length} sentences!`, 'success');
    } catch (error) {
        console.error('Error saving sentences:', error);
        showToast('Error processing text', 'error');
    }
});
            
            // Reading view controls
            elements.prevSentenceBtn.addEventListener('click', () => {
                if (state.currentSentenceIndex > 0) {
                    state.currentSentenceIndex--;
                    displaySentence();
                }
            });
elements.translateBtn.addEventListener('click', async () => {
    if (state.sentences.length === 0 || !elements.translationDisplay) return;
    
    const sentence = state.sentences[state.currentSentenceIndex].original;
    elements.translationDisplay.style.display = 'block';
    elements.translationDisplay.textContent = "Translating...";
    
    const translation = await translateSentence(sentence);
    elements.translationDisplay.textContent = translation;
    
    // Store the translation in cache
    state.sentences[state.currentSentenceIndex].cached_translation = translation;
    
    // Pre-translate next few sentences in background
    if (state.currentSentenceIndex < state.sentences.length - 1) {
        const nextSentences = state.sentences.slice(
            state.currentSentenceIndex + 1,
            Math.min(state.currentSentenceIndex + 4, state.sentences.length)
        );
        
        nextSentences.forEach(async (sentenceObj, index) => {
            if (!sentenceObj.user_translation) {
                const translation = await translateSentence(sentenceObj.original);
                state.sentences[state.currentSentenceIndex + 1 + index].cached_translation = translation;
            }
        });
    }
});
            elements.nextSentenceBtn.addEventListener('click', () => {
                if (state.currentSentenceIndex < state.sentences.length - 1) {
                    state.currentSentenceIndex++;
                    displaySentence();
                }
            });
            
            elements.ttsButton.addEventListener('click', () => {
                if (state.sentences.length > 0) {
                    const sentence = state.sentences[state.currentSentenceIndex].original;
                    speakText(sentence);
                }
            });
            

            
// Word selection
elements.sentenceDisplay.addEventListener('mouseup', handleTextSelection);
elements.sentenceDisplay.addEventListener('touchend', handleTextSelection);

function handleTextSelection() {
    const selection = window.getSelection().toString().trim();
    if (selection.length > 0) {
        elements.selectedWord.textContent = selection;
        elements.vocabTranslation.value = '';
        elements.wordSelectionBox.style.display = 'block';
        
        // Scroll to the selection box if on mobile
        if (window.innerWidth <= 600) {
            elements.wordSelectionBox.scrollIntoView({ behavior: 'smooth' });
        }
    }
}

// Add to vocab handler
elements.addToVocabBtn.addEventListener('click', async () => {
    const word = elements.selectedWord.textContent;
    const translation = elements.vocabTranslation.value.trim();
    
    if (!translation) {
        showToast('Please enter a translation', 'error');
        return;
    }
    
    const newWord = {
        id: generateUUID(),
        word: word,
        translation: translation,
        sentence_id: state.sentences[state.currentSentenceIndex].id,
        bucket: 'new',
        streak: 0,
        consecutiveMisses: 0
    };
    
    try {
        await addVocabWord(newWord);
        showToast(`"${word}" added to vocabulary!`, 'success');
        elements.wordSelectionBox.style.display = 'none';
        updateBucketCounts();
    } catch (error) {
        if (error.message === 'Word already exists in vocabulary') {
            showToast(`"${word}" is already in your vocabulary!`, 'error');
        } else {
            showToast('Error adding word', 'error');
            console.error(error);
        }
    }
});
            
            // Vocabulary review
            document.querySelectorAll('.bucket-card').forEach(card => {
                card.addEventListener('click', () => {
                    document.querySelectorAll('.bucket-card').forEach(c => {
                        c.style.opacity = '1';
                        c.style.transform = 'scale(1)';
                    });
                    
                    card.style.opacity = '0.9';
                    card.style.transform = 'scale(0.98)';
                    state.reviewMode = card.dataset.bucket;
                    
                    elements.startReviewBtn.disabled = false;
                    elements.startReviewBtn.textContent = `Review ${card.dataset.bucket} words`;
                });
            });
            
            elements.startReviewBtn.addEventListener('click', () => {
                if (state.reviewMode) {
                    startReview(state.reviewMode);
                }
            });
            
            // Review mode

            
            elements.exitReviewBtn.addEventListener('click', () => {
                showView('vocab-review-view');
            });
            
            // Theme toggle
            elements.themeToggle.addEventListener('click', toggleTheme);
        }
async function removeDuplicateWords() {
    return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_VOCAB], 'readwrite');
        const store = transaction.objectStore(STORE_VOCAB);
        
        // First check if the index exists
        if (!store.indexNames.contains('word')) {
            console.log('Word index does not exist, skipping duplicate removal');
            resolve(0);
            return;
        }
        
        const wordIndex = store.index('word');
        const uniqueWords = new Set();
        const duplicates = [];
        
        // Open cursor to go through all words
        const request = store.openCursor();
        
        request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
                const word = cursor.value.word;
                if (uniqueWords.has(word)) {
                    duplicates.push(cursor.value.id);
                } else {
                    uniqueWords.add(word);
                }
                cursor.continue();
            } else {
                // Cursor has completed
                if (duplicates.length > 0) {
                    let deletedCount = 0;
                    duplicates.forEach(id => {
                        const deleteRequest = store.delete(id);
                        deleteRequest.onsuccess = () => {
                            deletedCount++;
                            if (deletedCount === duplicates.length) {
                                resolve(deletedCount);
                            }
                        };
                        deleteRequest.onerror = (event) => reject(event.target.error);
                    });
                } else {
                    resolve(0);
                }
            }
        };
        
        request.onerror = (event) => reject(event.target.error);
    });
} 
        // Initialize the app
        async function initApp() {
            try {
                await openDatabase();
await removeDuplicateWords();
                state.sentences = await getAllSentences();
                
                if (state.sentences.length > 0) {
                    document.querySelector('.nav-btn[data-view="text-import"]').classList.remove('active');
                    document.querySelector('.nav-btn[data-view="vocab-review"]').classList.add('active');
                    showView('vocab-review-view');
                }
                
                await updateBucketCounts();
                setupEventListeners();
                
                // Apply theme
                document.documentElement.setAttribute('data-theme', state.theme);
                elements.themeToggle.textContent = state.theme === 'dark' ? '🌙' : '☀️';
                
                // Pre-warm TTS
                if ('speechSynthesis' in window) {
                    // Load voices
                    speechSynthesis.getVoices();
                }
                
                // Service worker registration for PWA
                if ('serviceWorker' in navigator) {
                    navigator.serviceWorker.register('sw.js').catch(error => {
                        console.log('Service Worker registration failed:', error);
                    });
                }
                
            } catch (error) {
                console.error('Initialization error:', error);
                showToast('Failed to initialize app', 'error');
            }
        }
        
        // Start the app
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
